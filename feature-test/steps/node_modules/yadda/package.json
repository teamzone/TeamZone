{
  "name": "yadda",
  "version": "0.10.12",
  "description": "A true BDD framework for JavaScript",
  "main": "./lib/index.js",
  "devDependencies": {
    "mocha": "*",
    "browserify": "*",
    "jshint": "^2.5.0"
  },
  "directories": {
    "example": "examples",
    "test": "test"
  },
  "scripts": {
    "test": "make test",
    "istanbul": "NODE_ENV=test istanbul cover _mocha -- -u exports --reporter spec",
    "examples": "node bin/examples.js",
    "browserify": "node bin/browserify.js",
    "jshint": "find . -name *.js | grep -vE '/node_modules/|/dist/|/components/|/component-browser/build/|/coverage/|qunit-1.10.0.js' | xargs ./node_modules/.bin/jshint"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/acuminous/yadda.git"
  },
  "keywords": [
    "BDD",
    "Specification",
    "Natural",
    "Test",
    "Behaviour",
    "Driven",
    "Jasmine",
    "Mocha",
    "QUnit",
    "Nodeunit"
  ],
  "author": {
    "name": "Stephen Cresswell"
  },
  "license": "Apache2",
  "readmeFilename": "README.md",
  "gitHead": "4754e8449c4f6d28e6357059287079a44a0dad29",
  "readme": "# Yadda\n[![Build Status](https://travis-ci.org/acuminous/yadda.png)](https://travis-ci.org/acuminous/yadda)\n\nYadda brings _true_ BDD to JavaScript test frameworks such as [Jasmine](http://pivotal.github.io/jasmine/), [Mocha](http://visionmedia.github.io/mocha/), [QUnit](http://qunitjs.com), [Nodeunit](https://github.com/caolan/nodeunit), [WebDriverJs](code.google.com/p/selenium/wiki/WebDriverJs) and [CasperJS](http://casperjs.org). By _true_ BDD we mean that the ordinary language (e.g. English) steps are mapped to code, as opposed to simply decorating it. This is important because just like comments, the decorative steps such as those used by\n[Jasmine](http://pivotal.github.com/jasmine), [Mocha](http://visionmedia.github.io/mocha) and [Vows](http://vowsjs.org) can fall out of date and are a form of duplication.\n\nYadda's BDD implementation is like [Cucumber's](http://cukes.info/) in that it maps the ordinary language steps to code. Not only are the steps less likely to go stale, but they also provide a valuable abstraction layer and encourage re-use. You could of course just use [CucumberJS](https://github.com/cucumber/cucumber-js), but we find Yadda less invasive and prefer it's flexible syntax to Gherkin's. Yadda's conflict resolution is smarter too.\n\n## Latest Version\nThe current version of Yadda is 0.10.12. Recent changes include:\n* Adds support for mocha's only feature to the Mocha plugin - see [issue-98](https://github.com/acuminous/yadda/issues/98)\n* Fixes [issue-97](https://github.com/acuminous/yadda/issues/97) which caused the parser to fail if the scenario following a background was annotated.\n* Added jshint\n* Added a basic example\n```\nvar Yadda = require('yadda');\nYadda.plugins.mocha.AsyncScenarioLevelPlugin.init();\n\nnew Yadda.FeatureFileSearch('features').each(function(file) {\n\n    // Previously features(file, function(feature))\n    featureFile(file, function(feature) {\n\n        var library = require('./bottles-library');\n        var yadda = new Yadda.Yadda(library);\n\n        scenarios(feature.scenarios, function(scenario, done) {\n            yadda.yadda(scenario.steps, done);\n        });\n    });\n});\n```\nTo get step level output use SyncStepLevelPlugin or AsyncStepLevelPlugin as appropriate, e.g.\n```\nvar Yadda = require('yadda');\nYadda.plugins.mocha.AsyncStepLevelPlugin.init();\n\nnew Yadda.FeatureFileSearch('features').each(function(file) {\n\n    // Previously features(file, function(feature))\n    featureFile(file, function(feature) {\n\n        var library = require('./bottles-library');\n        var yadda = new Yadda.Yadda(library);\n\n        scenarios(feature.scenarios, function(scenario) {\n            steps(scenario.steps, function(step, done) {\n                yadda.yadda(step, done);\n            })\n        });\n    });\n});\n```\nPart of the reason for the rewrite was to pave the way for karma integration as requested by [zpratt](https://github.com/zpratt). This feature is next on the list.\n\n\n\n## Installation\n\n### Node based environments (e.g. Mocha)\n```\nnpm install yadda\n```\n### Browser based environments (e.g. QUnit)\n```html\n<script src=\"./lib/yadda-0.10.12.js\"></script>\n```\n## Writing Yadda Tests\n### Step 1 - Decide upon a directory structure, e.g.\n```\n.\n├── index.js\n├── package.json\n├── lib\n└── test\n    ├── features\n    └── steps\n```\n\n### Step 2 - Write your first scenario\n./test/features/bottles.feature\n```\nFeature: 100 Green Bottles\n\nScenario: Should fall from the wall\n\n   Given 100 green bottles are standing on the wall\n   When 1 green bottle accidentally falls\n   Then there are 99 green bottles standing on the wall\n\n```\n### Step 3 - Implement the step library\n./test/steps/bottles-library.js\n```js\nvar assert = require('assert');\nvar English = require('yadda').localisation.English;\nvar Wall = require('../../lib/wall'); // The library that you wish to test\n\nmodule.exports = (function() {\n  return English.library()\n    .given(\"$NUM green bottles are standing on the wall\", function(number, next) {\n       wall = new Wall(number);\n       next();\n    })\n    .when(\"$NUM green bottle accidentally falls\", function(number, next) {\n       wall.fall(number);\n       next();\n    })\n    .then(\"there are $NUM green bottles standing on the wall\", function(number, next) {\n       assert.equal(number, wall.bottles);\n       next();\n    });\n})();\n```\n(If your test runner & code are synchronous you can omit the calls to 'next')\n\n\n### Step 4 - Integrate Yadda with your testing framework (e.g. Mocha)\n./test/steps/bottles-library.js\n```js\nvar Yadda = require('yadda');\nYadda.plugins.mocha.AsyncStepLevelPlugin.init();\n\nnew Yadda.FeatureFileSearch('./test/features').each(function(file) {\n\n  featureFile(file, function(feature) {\n\n    var library = require('./bottles-library');\n    var yadda = new Yadda.Yadda(library);\n\n    scenarios(feature.scenarios, function(scenario) {\n      steps(scenario.steps, function(step, done) {\n        yadda.yadda(scenario.steps, done);\n      });\n    });\n  });\n});\n```\n### Step 5 - Write your code\n./lib/wall.js\n```js\nmodule.exports = function(bottles) {\n  this.bottles = bottles;\n  this.fall = function(n) {\n    this.bottles -= n;\n  }\n};\n```\n### Step 6 - Run your tests\n```\n  mocha --reporter spec bottles-test.js\n\n  100 Green Bottles\n    Should fall from the wall\n      ✓ Given 100 green bottles are standing on the wall\n      ✓ When 1 green bottle accidentally falls\n      ✓ Then there are 99 green bottles standing on the wall\n```\n\n## Yadda In Depth\n### Supported Libraries\nYadda works with Mocha, Jasmine, QUnit, Nodeunit, ZombieJS, CasperJS and WebDriver. There are examples for most of these, which can be run as follows...\n\n```bash\ngit clone https://github.com/acuminous/yadda.git\ncd yadda\nnpm install\nnpm link\nnpm run examples\n```\n\nAlternatively you can run them individually\n\n```bash\ngit clone https://github.com/acuminous/yadda.git\ncd yadda\nnpm install\nnpm link\ncd examples/<desired-example-folder>\nnpm install\nnpm test\n```\n\n**Please note:**\n* The Zombie example doesn't install on windows\n* The webdriver example may fail depending on how google detects your locale.\n* Your operating system must support ```npm link```.\n\n### Flexible BDD Syntax\nIt's common for BDD libraries to limit syntax to precondition (given) steps, action (when) steps and assertion (then) steps. Yadda doesn't. This allows for more freedom of expression. e.g.\n```js\nvar library = new Yadda.Library()\n    .define(\"$NUM green bottle(?:s){0,1} standing on the wall\", function(number) {\n        // some code\n    })\n    .define(\"if $NUM green bottle(?:s){0,1} should accendentally fall\", function(number) {\n        // some code\n    })\n    .define(\"there are $NUM green bottle(?:s){0,1} standing on the wall\", function(number) {\n        // some code\n    });\nnew Yadda.yadda(library).yadda([\n    \"100 green bottles standing on the wall\",\n    \"if 1 green bottle should accidentally fall\",\n    \"there are 99 green bottles standing on the wall\"\n]);\n```\nHowever we think that Given/When/Then (along with And/But/With/If) is a good starting point, so we recommend using Yadda.localisation.English instead of the vanilla Yadda.Library. This adds 'given', 'when' and 'then' helper methods, enabling you to define your steps as follows...\n```js\nvar library = new Yadda.Library()\n    .given(\"$NUM green bottle(?:s){0,1} standing on the wall\", function(number) {\n        // some code\n    })\n    .when(\"$NUM green bottle(?:s){0,1} should accendentally fall\", function(number) {\n        // some code\n    })\n    .then(\"there are $NUM green bottle(?:s){0,1} standing on the wall\", function(number) {\n        // some code\n    });\nnew Yadda.yadda(library).yadda([\n    \"Given 100 green bottles standing on the wall\",\n    \"when 1 green bottle should accidentally fall\",\n    \"then there are 99 green bottles standing on the wall\"\n]);\n```\nBecause the localised definitions for 'given', 'when' and 'then' are loose you could also re-write the above scenario as\n```js\nnew Yadda.yadda(library).yadda([\n    \"given 100 green bottles standing on the wall\",\n    \"but 1 green bottle should accidentally fall\",\n    \"expect there are 99 green bottles standing on the wall\"\n]);\n```\n\n### Localisation\nWe'd be delighted to accept pull requests for more languages and dialects. Many thanks to the following language contributors\n\n - [ami44](https://github.com/ami44) - French\n - [feliun](https://github.com/feliun) - Spanish\n - [kjelloe](https://github.com/kjelloe) - Norwegian\n - [macie](https://github.com/macie) - Polish\n\n### Step Anatomy\nA step is made up of a regular expression, a function and some context.\n```js\nvar ctx = { assert: assert };\nlibrary.given('^(\\\\d+) green bottle(?:s){0,1} standing on the wall$', function(n) {\n   wall = new Wall(n);\n   this.assert.equals(wall.bottles, n);\n}, ctx);\n```\n\n#### Regular Expressions\nThe regular expression is used to identify which steps are compatible with the input text, and to provide arguments to the function. You can specify step signatures using true RegExp objects, which is handy if they contain lots of backslash characters. e.g.\n```js\nvar library = Yadda.Library.English.library()\n    .given(/^(\\d+) green bottle(?:s){0,1} standing on the wall$/, function(n) {\n        // some code\n    });\n```\nRegular expressions can get pretty ugly, so it's often preferable to relax the regex and use a $term variable which will be replaced with a wildcard i.e. '(.+)'.\n```js\nvar library = Yadda.Library.English.library()\n    .given(/$NUM green bottles standing on the wall/, function(n) {\n        // some code\n    });\n```\nUsing $term variables can relax the regular expression too much and cause clashes between steps. Yadda provides greater control over the expansion through use of a dictionary, e.g.\n```js\nvar dictionary = new Yadda.Dictionary()\n    .define('gender', '(male|female)')\n    .define('speciaility', '(cardio|elderly|gastro)');\n\nvar library = Yadda.localisation.English.library(dictionary)\n    .given('a $gender, $speciality patient called $name', function(gender, speciality, name) { /* some code */ });\n```\nwill expand to\n```js\n\"(?:[Gg]iven|[Aa]nd|[Ww]ith]|[Bb]ut) a (male|female), (cardio|elderly|gastro) patient called (.+)\"\n```\nand therefore match \"Given a female, elderly patient called Carol\". The expansions can also contain $terms so\n```js\nvar dictionary = new Yadda.Dictionary()\n    .define('address_line_1', '$number $street')\n    .define('number', /(\\d+)/)\n    .define('street', /(\\w+)/);\n\nvar library = Yadda.Library.English.localisation(dictionary)\n    .given('a street address of $address_line_1', function(number, street) { /* some code */ });\n```\nwill expand to\n```js\n\"(?:[Gg]iven|[Aa]nd|[Ww]ith]|[Bb]ut) a street address of (\\d+) (\\w+)\"\n```\nDictionaries can also be merged...\n```js\nvar shared_dictionary = new Yadda.Dictionary()\n    .define('number', /(\\d+1/));\n\nvar feature_specific_dictionary = new Yadda.Dictionary()\n    .merge(shared_dictionary)\n    .define('speciality', /(cardio|elderly|gastro)/);\n```\nAn alternative way to make your regular expressions more readable is to alias them. So instead of...\n```js\n    .given('$patient is (?:still )awaiting discharge', function(patient) {\n        // some code\n    });\n```\nYou could write\n```js\n    .given(['$patient is awaiting discharge', '$patient is still waiting discharge'], function(patient) {\n        // some code\n    });\n```\n\n#### Functions\nThe function is the code you want to execute for a specific line of text. If you don't specify a function then a no-op\nfunction will be used, which is one way of implementing a 'Pending' step.\n\n#### Contexts (Shared State)\nThe context will be bound with the function before it is executed and provides a non global way to share state between\nsteps, or pass in \"define-time\" variables such as an assertion library or 'done' function. The context is optional.\n\nIt can be a chore to add a context to every step, so a common context can be specified at the interpreter and scenario levels too. If you specify multiple contexts (as in the following example) they will be merged before executing the step.\n\n```js\nvar interpreter_context = { foo: 1, masked: 2 }; // Shared between all scenarios\nvar scenario_context = { bar: 3, masked: 4 };    // Shared between all steps in this scenario\nvar step_context = { meh: 5, masked: 6 };        // Not shared between steps\n\nvar library = new Library()\n    .define('Context Demonstration', function() {\n        assert(this.foo == 1);\n        assert(this.bar == 3);\n        assert(this.meh == 5);\n        assert(this.masked == 6);\n    }, step_context);\n\nnew Yadda.yadda(library, interpeter_context).yadda('Context Demonstration', scenario_context);\n\n```\n\n#### Step Conflicts\nOne issue you find with BDD libraries, is that two steps might match the same input text. Usually this results in an error, and you end up having to add some extra text to one of the steps in order to differentiate it. Yadda attempts to minimise this in three ways.\n\n1. By using the Levenshtein Distance to determine which step is the best match when clashes occur.\n\n2. By allowing you to define steps in multiple libraries. Grouping steps into libraries not only helps keep a tidy code base, but also prevents clashes if your scenario doesn't require the library with the alternative step.\n\n3. If you still have problems with clashing, you can use the term dictionary to make your regular expression more specific without affecting the readability of your step.\n\n#### Events\nDebugging BDD tests is typically harder than debugging unit tests for a number of reasons, not the least of which is because you can't step through a feature file. You can make things a bit easier by adding event listeners, which log the step that is being executed.\n\n```js\nvar EventBus = require('Yadda').EventBus;\nEventBus.instance().on(EventBus.ON_EXECUTE, function(event) {\n    console.log(event.name, event.data);\n});\n\n```\nThe following events are available...\n<table>\n  <tr>\n    <th>Event Name</th><th>Event Data</th>\n  </tr>\n  <tr>\n    <td>ON_SCENARIO</td><td>{ scenario: [ '100 green bottles', 'should 1 green bottle...', ...], ctx: context }</td>\n  </tr>\n  <tr>\n    <td>ON_STEP</td><td>{ step: '100 green bottles...', ctx: context }</td>\n  </tr>\n  <tr>\n    <td>ON_EXECUTE</td><td>{ step: '100 green bottles...', pattern: '/(\\d+) green bottles.../', args: ['100'], ctx: context }</td>\n  </tr>\n</table>\n\n#### Coverage\nPlease note coverage may appear to hang on OSX, while causing the CPU to thrash. This is because the Yadda examples use symbolic links back to the top level directory,\ncreating an infinite loop. Istanbul follows these links indefinitely. The problem doesn't present itself on other linux-based distributions.\n```\nnpm install istanbul -g\nnpm install mocha -g\nnpm run istanbul\n```\nOpen ```coverage/lcov-report/lib/localisation/index.html``` with your browser\n\n## Feature Files\nWhile Yadda can interpret any text you write steps for, it also comes with a Gherkin-like feature file parser.\n\n### Backgrounds\nA background is a set of steps that are executed before each scenario in the corresponding feature file.\n```\nFeature: 100 Green Bottles\n\nBackground:\n\n   Given a 6ft wall\n   With a healthy amount of moss\n\nScenario: Bottles should fall from the wall\n\n   Given 100 green bottles are standing on the wall\n   When 1 green bottles accidentally falls\n   Then there are 99 green bottles standing on the wall\n\nScenario: Plastic bottles should not break\n\n   Given 100 plastic bottles are standing on the wall\n   When 1 plastic bottles accidentally falls\n   It does not break\n```\nBackgrounds have the following limitations:\n\n* They cannot be shared between features\n* A feature can only have one background\n* A background will be added to every scenario in a feature\n\nA more flexible approach would be to support [re-use of scenarios](http://github.com/acuminous/yadda/issue/27).\nThe implications of this are more complicated and are still under consideration.\n\n### Feature Descriptions\nYou can add an optional feature description at the top of your file to give some context about the scenarios contained within\n```\nFeature: Bystander is amused by watching falling bottles\nAs a bystander,\nI can watch bottles falling from a wall\nso that I can be mildly amused\n\nScenario: should fall from the wall\n\n   Given 100 green bottles are standing on the wall\n   When 1 green bottle accidentally falls\n   Then there are 99 green bottles standing on the wall\n```\n\nThere can only be a single feature present in a file - it really doesn't make sense to have two, and you will be issued an error if you try to include more than one.\n\n### Annotations\nAnnotations can be added to a feature or scenario and may take the form of either single-value tags or key/value pairs.\n```\n@Browser=chrome\n@Theme=bottles\nFeature: As a bystander\n    I can watch bottles falling from a wall\n    So that I can be mildly amused\n\n@Teardown\nScenario: should fall from the wall\n\n   Given 100 green bottles are standing on the wall\n   When 1 green bottle accidentally falls\n   Then there are 99 green bottles standing on the wall\n```\nNext you'll need to write the code that processes the annotations from the parsed feature or scenario, e.g.\n\n```js\nvar Yadda = require('yadda');\n\nvar all_features = new Yadda.FileSearch('features').list();\n\nfeatures(all_features, function(feature) {\n\n    console.log(feature.annotations.theme);\n\n    var library = require('./bottles-library');\n    var yadda = new Yadda.Yadda(library);\n\n    scenarios(feature.scenarios, function(scenario) {\n        if (scenario.annotations.teardown) library.teardown();\n        yadda.yadda(scenario.steps);\n    });\n});\n```\nThe mocha and jasmine plugins already support @Pending annotations on features and scenarios out of the box, although [skipping tests in jasmine causes them to be excluded from the report](https://github.com/pivotal/jasmine/issues/274).\n\n### Comments\nYou can add single line or block comments too.\n```\n###\n  This is  a\n  block comment\n###\nFeature: As a bystander\n    I can watch bottles falling from a wall\n    So that I can be mildly amused\n\n# Marked as pending until verified by customer - SC 300BC\n@Pending\nScenario: should fall from the wall\n\n   Given 100 green bottles are standing on the wall\n   When 1 green bottle accidentally falls\n   Then there are 99 green bottles standing on the wall\n```\nBut you can't do this...\n```\nFeature: As a bystander\n    I can watch bottles falling from a wall\n\n    # A blank line will always terminate a feature or scenario description\n\n    So that I can be mildly amused\n```\n### Example Tables\nExample Tables are supported as of 0.9.0. When the following feature file is parsed\n\nbottles.feature\n```\nFeature: 100 Green Bottles\n\nScenario: should fall in groups of [Falling]\n\n   Given 100 green bottles are standing on the wall\n   When [Falling] green bottles accidentally fall\n   Then there are [Remaining] green bottles standing on the wall\n\n   Where:\n      Falling | Remaining\n      2       | 98\n      10      | 90\n      100     | 0\n```\nit will produce three scenarios, identical to\n```\nFeature: 100 Green Bottles\n\nScenario: should fall in groups of 2\n\n   Given 100 green bottles are standing on the wall\n   When 2 green bottles accidentally fall\n   Then there are 98 green bottles standing on the wall\n\nScenario: should fall in groups of 10\n\n   Given 100 green bottles are standing on the wall\n   When 10 green bottles accidentally fall\n   Then there are 90 green bottles standing on the wall\n\nScenario: should fall in groups of 100\n\n   Given 100 green bottles are standing on the wall\n   When 100 green bottles accidentally fall\n   Then there are 0 green bottles standing on the wall\n```\n",
  "bugs": {
    "url": "https://github.com/acuminous/yadda/issues"
  },
  "_id": "yadda@0.10.12",
  "_from": "yadda@"
}
